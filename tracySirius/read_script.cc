/****************************************************************************/
/* void read_script(const char *param_file_name, bool rd_lat)

   Purpose:
       read script written by the user.
       1) User can specify lattice file name, vacuum chamber name, and bool flags such as tune 
          tracking flag, tune shift with energy flag, etc.
       2) In this function, Lattice is read, bool flags are set. 

   Input:
       param_file_name  user script name

   Output:
       none

   Return:
       global values and global bool flags 

   Global variables:
       bool flags

   specific functions:
       Read_Lattice()

   Comments:
       Written by Jianfeng Zhang 03/2011 soleil

 ****************************************************************************/

#include "tracy_lib.h"

/* files */ 
//twiss file
char twiss_file[max_str];
// cod file
char cod_file[max_str];
// girder file
char girder_file[max_str];
//chamber file

// multipole files
char multipole_file[max_str];
// multipole file for soleil lattice
char fic_hcorr[max_str],fic_vcorr[max_str], fic_skew[max_str];

//errors
//char fe_file[max_str]; //the same as multipole_file[max_str]????

/* COD correction */
int nwh = 56, nwv = 56; //number of singular values for SVD correction

//correction
char hcorr_file[max_str], vcorr_file[max_str]; //files with the status of hcorr/vcorr status, 
//to choose which correctors are used for orbit correction
//default name of special elements in lattice
char hcorr_name[max_str] = "", vcorr_name[max_str] = "";
char skew_quad_name[max_str] = "", bpm_name[max_str] = "";
char gs_name[max_str] = "", ge_name[max_str] = "";

//#define OLD_LATTICE

/*  Read script   */
void read_script(const char *param_file_name, bool rd_lat, long& CommNo, UserCommand UserCommandFlag[])
{


	char    str[max_str]="voidstring", dummy[max_str]="voidstring";
	char    in[max_str];  //temporary line with preceding white space
	char    *line; //line to store the command without preceding white space
	char    name[max_str]="voidname";
	char    lat_file[max_str]="voidlattice";
	char    EndName[]="void";

	FILE    *inf;
	const bool  prt = false; // for debugging printout each line of input file
	long int    LineNum=0L;
	long int    NameLen=0L;
	int idummy=0;
	char full_param_file_name[max_str];
	char lat_FileName[max_str];
	//bool TuneTracFlag;
	char *pch;


	// Manipulation of the parameter file
	strcpy(dummy, param_file_name);
	pch = strstr (dummy,".prm"); // search for extension .prm
	/* remove additional .prm if exist */
	if (pch != NULL) strncpy(pch,"\0",1);

	sprintf(full_param_file_name,"%s.prm",dummy);
	if (prt) printf("\n reading in script file: %s\n",full_param_file_name);

	//
	inf = file_read(full_param_file_name);


	// read parameter file, line by line
	//  while (fgets(line, max_str, inf) != NULL) {
	while (line = fgets(in, max_str, inf)) {

		/* kill preceding whitespace generated by "table" key
        or "space" key, but leave \n 
        so we're guaranteed to have something*/
		while(*line == ' ' || *line == '\t') {
			line++;
		}

		if(prt)
			printf("cfg: %s",line);

		LineNum++;

		/* read the end of line symbol '\n','\r' or '\r\n' at different operation system*/
		if (strstr(line, "#") == NULL && strcmp(line,"\n") != 0 &&
				strcmp(line,"\r") != 0 && strcmp(line,"\r\n") != 0) {
			// get initial command token
			sscanf(line, "%s", name);



			//find the sequence of the bool flag in user input script
			NameLen = strlen(name);
			EndName[0] = name[NameLen-4];
			EndName[1] = name[NameLen-3];
			EndName[2] = name[NameLen-2];
			EndName[3] = name[NameLen-1];

			//find the bool flag whose last 4 character are 'Flag'
			if(strcmp(EndName,"Flag")==0)
				CommNo++;


			/*read file names................. */
			/* set file directory*/
			if (strcmp("in_dir", name) == 0)
				sscanf(line, "%*s %s", in_dir);
			/* lattice file......*/
			else if (strcmp("lat_file", name) == 0){
				sscanf(line, "%*s %s", lat_file);
				sprintf(lat_FileName, "%s%s", in_dir, lat_file);
				if(rd_lat) { // Fernando 2012/08/30
					if(strncmp("flat_file",lat_file,9)==0){ // if lattice file is a flat_file
						fprintf(stdout, "Reading lattice from flat_file");
						lnls_read_lattice(lat_FileName);
					}
					else{
						fprintf(stdout, "Reading lattice"); // if lattice file is a .lat file
						Read_Lattice(lat_FileName);
					}

//#else
  //         fprintf(stderr, "Reading lattice with new parser\n");
  //          sprintf(lat_FileName, "%s%s.lat", in_dir, lat_file);
  //          parse_lattice_flat(lat_FileName, "new.flat");
  //          fprintf(stderr, "Parse the lattice into new.flat\n");
  //          rdmfile("new.flat");
  //          sprintf(lat_FileName, "%s%s", in_dir, lat_file);

//#endif
				}

			}

			/* other file names.....*/
			else if (strcmp("multipole_file", name) == 0){
				sscanf(line, "%*s %s", str);
				sprintf(multipole_file,"%s%s", in_dir, str); /* add file directory of the multipole file*/
			}

			/* read in bool flags */
			else if (strcmp("QuadFringeOnFlag", name) == 0){
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			else if (strcmp("RFvoltageFlag", name) == 0){
				sscanf(line, "%*s %lf", &(UserCommandFlag[CommNo].RFvolt));
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			else if (strcmp("CavityFlag", name) == 0){
				sscanf(line, "%*s %s", UserCommandFlag[CommNo].CavityFlag);
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			else if (strcmp("VacuumChamberFlag", name) == 0){
				sscanf(line, "%*s %s", UserCommandFlag[CommNo].VacuumChamberFlag);
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			else if (strcmp("RadiationFlag", name) == 0){
				sscanf(line, "%*s %s", UserCommandFlag[CommNo].RadiationFlag);
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			//read chamber file flat
			else if (strcmp("ReadChamberFlag", name) == 0){
				sscanf(line, "%*s %s", str);
				sprintf(UserCommandFlag[CommNo].chamber_file,"%s%s", in_dir, str);
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			//read field error, GENERIC command
			else if (strcmp("ReadfefileFlag", name) == 0){
				sscanf(line, "%*s %s", str);
				sprintf(UserCommandFlag[CommNo].fe_file,"%s%s", in_dir, str);
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			//read misalignment error, then do orbit correction
			else if (strcmp("ReadaefileFlag", name) == 0){
				sscanf(line, "%*s %s", str);
				sprintf(UserCommandFlag[CommNo].ae_file,"%s%s", in_dir, str);
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}


			//read multipole errors; specific for SOLEIL lattice
			else if (strcmp("ReadMultipoleFlag", name) == 0){
				strcpy(UserCommandFlag[CommNo].CommandStr,name);

			}else if (strcmp("fic_hcorr", name) == 0){// read of h-correctors for multipoles
				sscanf(line, "%*s %s", str);
				sprintf(fic_hcorr,"%s%s", in_dir, str);
			}else if (strcmp("fic_vcorr", name) == 0){// read of v-correctors for multipoles
				sscanf(line, "%*s %s", str);
				sprintf(fic_vcorr,"%s%s", in_dir, str);
			}else if (strcmp("fic_skew", name) == 0){// read of skew quads for multipoles
				sscanf(line, "%*s %s", str);
				sprintf(fic_skew,"%s%s", in_dir, str);
			}
			//print twiss parameters flag
			else if (strcmp("PrintTwissFlag", name) == 0){
				sscanf(line, "%*s %s", twiss_file);
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			//print close orbit(COD) flag
			else if (strcmp("PrintCODFlag", name) == 0){
				sscanf(line, "%*s %s", cod_file);
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			//print close orbit(COD) flag
			else if (strcmp("PrintGirderFlag", name) == 0){
				sscanf(line, "%*s %s", girder_file);
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}


			else if (strcmp("TuneTracFlag", name) == 0){
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			else if (strcmp("ChromTracFlag", name) == 0){
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			// FMA
			else if (strcmp("FmapFlag", name) == 0){
				strcpy(dummy, "");
				sscanf(line, "%*s %ld %ld %ld %lf %lf %lf %lf %lf %s",
						&(UserCommandFlag[CommNo]._FmapFlag_nxpoint),
						&(UserCommandFlag[CommNo]._FmapFlag_nypoint), &(UserCommandFlag[CommNo]._FmapFlag_nturn),
						&(UserCommandFlag[CommNo]._FmapFlag_x0), &(UserCommandFlag[CommNo]._FmapFlag_xmax),
						&(UserCommandFlag[CommNo]._FmapFlag_y0), &(UserCommandFlag[CommNo]._FmapFlag_ymax),
						&(UserCommandFlag[CommNo]._FmapFlag_delta), dummy);

				// FmapFlag = true;
				strcpy(UserCommandFlag[CommNo].CommandStr,name);

				if(strcmp(dummy, "true") == 0)
					UserCommandFlag[CommNo]._FmapFlag_diffusion = true;
				else if(strcmp(dummy, "false") == 0)
					UserCommandFlag[CommNo]._FmapFlag_diffusion = false;
				else {
					printf("set boolean flag true or false for FMA Diffusion (value is %s) \n", dummy);
					exit_(1);
				}
			}
			// FMA dp
			else if (strcmp("FmapdpFlag", name) == 0){
				strcpy(dummy, "");
				sscanf(line, "%*s %ld %ld %ld %lf %lf %lf %lf %lf %s",
						&(UserCommandFlag[CommNo]._FmapdpFlag_nxpoint),
						&(UserCommandFlag[CommNo]._FmapdpFlag_nepoint), &(UserCommandFlag[CommNo]._FmapdpFlag_nturn),
						&(UserCommandFlag[CommNo]._FmapdpFlag_x0), &(UserCommandFlag[CommNo]._FmapdpFlag_xmax),
						&(UserCommandFlag[CommNo]._FmapdpFlag_emin),&(UserCommandFlag[CommNo]._FmapdpFlag_emax),
						&(UserCommandFlag[CommNo]._FmapdpFlag_z),
						dummy);

				//  FmapdpFlag = true;
				strcpy(UserCommandFlag[CommNo].CommandStr,name);

				if(strcmp(dummy, "true") == 0)
					UserCommandFlag[CommNo]._FmapdpFlag_diffusion = true;
				else if(strcmp(dummy, "false") == 0)
					UserCommandFlag[CommNo]._FmapdpFlag_diffusion = false;
				else {
					printf("set boolean flag true or false for FMAdp Diffusion (value is %s) \n", dummy);
					exit_(1);
				}
			}
			else if (strcmp("AmplitudeTuneShiftFlag", name) == 0){
				sscanf(line, "%*s %ld %ld %ld %lf %lf %lf",
						&(UserCommandFlag[CommNo]._AmplitudeTuneShift_nxpoint),
						&(UserCommandFlag[CommNo]._AmplitudeTuneShift_nypoint),
						&(UserCommandFlag[CommNo]._AmplitudeTuneShift_nturn),
						&(UserCommandFlag[CommNo]._AmplitudeTuneShift_xmax),
						&(UserCommandFlag[CommNo]._AmplitudeTuneShift_ymax),
						&(UserCommandFlag[CommNo]._AmplitudeTuneShift_delta));
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			else if (strcmp("EnergyTuneShiftFlag", name) == 0){
				sscanf(line, "%*s  %ld %ld %lf",
						&(UserCommandFlag[CommNo]._EnergyTuneShift_npoint),
						&(UserCommandFlag[CommNo]._EnergyTuneShift_nturn),
						&(UserCommandFlag[CommNo]._EnergyTuneShift_deltamax));
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			else if (strcmp("ErrorCouplingFlag", name) == 0){
				sscanf(line, "%*s  %ld %lf",&(UserCommandFlag[CommNo].err_seed),&(UserCommandFlag[CommNo].err_rms));
				strcpy(UserCommandFlag[CommNo].CommandStr,name);

			}
			else if (strcmp("ErrorCoupling2Flag", name) == 0){
				sscanf(line, "%*s  %ld %lf",&(UserCommandFlag[CommNo].err_seed),&(UserCommandFlag[CommNo].err_rms));
				strcpy(UserCommandFlag[CommNo].CommandStr,name);

			}
			else if (strcmp("CouplingFlag", name) == 0){
				strcpy(UserCommandFlag[CommNo].CommandStr,name);

			}
			else if (strcmp("MomentumAccFlag", name) == 0){
				UserCommandFlag[CommNo]._MomentumAccFlag_nnames = 
				  sscanf(line, "%*s  %s %ld %lf %lf %ld %lf %lf %ld %lf %lf %s %s %s %s %s %s %s %s %s %s %s %s",
						UserCommandFlag[CommNo].TrackDim,
						&(UserCommandFlag[CommNo]._MomentumAccFlag_nturn),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_deltaminp),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_deltamaxp),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_nstepp),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_deltaminn),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_deltamaxn),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_nstepn),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_sstart),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_sstop),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_names[0]),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_names[1]),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_names[2]),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_names[3]),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_names[4]),
					    &(UserCommandFlag[CommNo]._MomentumAccFlag_names[5]),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_names[6]),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_names[7]),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_names[8]),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_names[9]),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_names[10]),
						&(UserCommandFlag[CommNo]._MomentumAccFlag_names[11]));
				UserCommandFlag[CommNo]._MomentumAccFlag_nnames -= 10;
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}

			//       generic one, fit for 1 family of quadrupoles
			else if (strcmp("FitTuneFlag", name) == 0){
				UserCommandFlag[CommNo].n_quads = sscanf(line,"%*s %lf %lf %s %s %s %s %s",&(UserCommandFlag[CommNo].targetnux),
						&(UserCommandFlag[CommNo].targetnuz), UserCommandFlag[CommNo].quads[0], UserCommandFlag[CommNo].quads[1],
						UserCommandFlag[CommNo].quads[2], UserCommandFlag[CommNo].quads[3], UserCommandFlag[CommNo].quads[4]);
				UserCommandFlag[CommNo].n_quads -=2; //number of quadrupole families for tune correction;
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			// fit for 2 families,specific for the soleil lattice in which the quadrupole is cut into 2 parts
			else if (strcmp("FitTune4Flag", name) == 0){
				sscanf(line, "%*s %s %s %s %s %lf %lf",UserCommandFlag[CommNo].qf1,UserCommandFlag[CommNo].qf2,
						UserCommandFlag[CommNo].qd1,UserCommandFlag[CommNo].qd2,
						&(UserCommandFlag[CommNo].targetnux),&(UserCommandFlag[CommNo].targetnuz));
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			else if (strcmp("FitChromFlag", name) == 0){
				sscanf(line, "%*s  %s %s %lf %lf",UserCommandFlag[CommNo].sxm1,UserCommandFlag[CommNo].sxm2,
						&(UserCommandFlag[CommNo].targetksix),&(UserCommandFlag[CommNo].targetksiz));
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			//       else if (strcmp("GirderErrorFlag", name) == 0){
			//        strcpy(UserCommand[CommandNo-1],name);
			//          // GirderErrorFlag = true;
			//
			//       }
			//        else if (strcmp("SigmaFlag", name) == 0){
			//         strcpy(UserCommand[CommandNo-1],name);
			//          // SigmaFlag = true;
			//
			//       }
			//        else if (strcmp("PX2Flag", name) == 0){
			//        strcpy(UserCommand[CommandNo-1],name);
			//          // PX2Flag = true;
			//
			//       }
			else if (strcmp("InducedAmplitudeFlag", name) == 0){
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			//        else if (strcmp("CodeComparaisonFlag", name) == 0){
			//        strcpy(UserCommand[CommandNo-1],name);
			//         //  CodeComparaisonFlag = true;
			//
			//       }
			else if (strcmp("EtaFlag", name) == 0){
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			else if (strcmp("PhaseSpaceFlag", name) == 0) {
				sscanf(line, "%*s %s %lf %lf %lf %lf %lf %lf %ld %s",
						UserCommandFlag[CommNo]._Phase_Dim,
						&(UserCommandFlag[CommNo]._Phase_X),
						&(UserCommandFlag[CommNo]._Phase_Px),
						&(UserCommandFlag[CommNo]._Phase_Y),
						&(UserCommandFlag[CommNo]._Phase_Py),
						&(UserCommandFlag[CommNo]._Phase_delta),
						&(UserCommandFlag[CommNo]._Phase_ctau),
						&(UserCommandFlag[CommNo]._Phase_nturn),
						str);
				if (strcmp(str, "true") == 0)
					UserCommandFlag[CommNo]._Phase_Damping = true;
				else if (strcmp(str, "false") == 0)
					UserCommandFlag[CommNo]._Phase_Damping = false;
				else {
					printf("set boolean flag true or false for PhaseSpaceFlag \n");
					exit_(1);
				}
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}
			//calculate Touschek lifetime
			else if (strcmp("TouschekFlag", name) == 0){
				strcpy(UserCommandFlag[CommNo].CommandStr,name);

			}//intra beam scattering
			else if (strcmp("IBSFlag", name) == 0) {
				//print close orbit(COD) flag
				sscanf(line, "%*s %lf %lf", 
					&(UserCommandFlag[CommNo]._Qb),
					&(UserCommandFlag[CommNo]._Coup));
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}//momentum acceptance is got by tracking, then cal touschek lifetime
			else if (strcmp("TousTrackFlag", name) == 0){
				strcpy(UserCommandFlag[CommNo].CommandStr,name);
			}

			//correctors for COD correction
			else if (strcmp("hcorr_file", name) == 0){
				sscanf(line, "%*s %s", str);
				sprintf(hcorr_file,"%s%s", in_dir, str); /* add file directory of the multipole file*/
			}
			else if (strcmp("vcorr_file", name) == 0){
				sscanf(line, "%*s %s", str);
				sprintf(vcorr_file,"%s%s", in_dir, str); /* add file directory of the multipole file*/
			}
			else if (strcmp("bpm_name", name) == 0){
				sscanf(line, "%*s %s", bpm_name); /* the name of bpm */
			}
			else if (strcmp("h_corr", name) == 0){
				sscanf(line, "%*s %s", hcorr_name); /* the name of H corrector used for COD correction*/
			}
			else if (strcmp("v_corr", name) == 0){
				sscanf(line, "%*s %s", vcorr_name); /* the name of V corrector used for COD correction*/
			}
			else if (strcmp("qt", name) == 0){
				sscanf(line, "%*s %s", skew_quad_name); /* name of skew quadrupoles */
			}
			else if (strcmp("gs", name) == 0){
				sscanf(line, "%*s %s", gs_name); /* name of start of the girder */
			}
			else if (strcmp("ge", name) == 0){
				sscanf(line, "%*s %s", ge_name); /* name of end of the girder */
			}

			else if (strcmp("normalcut", name) == 0){
				sscanf(line, "%*s %d", &idummy);
				fprintf(stdout,"User value for cutting at n sigma-s the normal distributions\n");
				setrancut(idummy); /* set normal cut for computation: random data are n sigma-s*/
			}
			//set parameters for COD correction
			else if (strcmp("n_orbit", name) == 0){
				sscanf(line, "%*s %d", &n_orbit);
			}
			else if (strcmp("n_scale", name) == 0){
				sscanf(line, "%*s %d", &n_scale);
			}
			else if (strcmp("n_stat", name) == 0){
				sscanf(line, "%*s %d", &n_stat);
			}
			else if (strcmp("nwh", name) == 0){
				sscanf(line, "%*s %d", &nwh);
			}
			else if (strcmp("nwv", name) == 0){
				sscanf(line, "%*s %d", &nwv);
			}
			else if (strcmp("nr_cpus", name) == 0){
				sscanf(line, "%*s %d", &(globval.nr_cpus));
			}
// Additional options for Sirius
			else if (strcmp("CorrectCouplingFlag", name) == 0){
				strcpy(UserCommandFlag[CommNo].CommandStr,name);	
			}
			else if (strcmp("n_coupl", name) == 0){
				sscanf(line, "%*s %d", &n_coupl);
			}

			else{
				printf("bad line in file %s, line %ld \n", full_param_file_name, LineNum);
				exit_(1);
			}
		}
		/* continue read in the line */
		else
			continue;
	}
	fclose(inf);
}  

